picoCTF Heap Buffer Overflow Challenge — heap 0
Overview
This repository documents my solution for a picoCTF binary exploitation challenge focused on a heap buffer overflow vulnerability. The challenge provided a binary (chall) and source code (chall.c) and required exploiting a mismanaged memory routine to retrieve the hidden flag.

Challenge Description
The program allocates two small buffers on the heap:

input_data — user-controlled buffer (5 bytes)

safe_var — “protected” buffer (5 bytes, initialized to "bico")

A menu interface allows:

Printing the current heap state

Writing to input_data

Printing the value of safe_var

Attempting to print the flag (only succeeds if safe_var != "bico")

Key flaw: Writing to input_data uses an unbounded scanf("%s", ...) call, allowing overflow into adjacent heap memory.

Steps to Exploit
1. Analyze the Source
Examined chall.c and noted:

input_data and safe_var allocated consecutively on the heap

The win condition (strcmp(safe_var, "bico") != 0)

Lack of bounds checking in user input

2. Local Testing
Ran the binary and confirmed that inputs longer than 5 characters into the buffer would corrupt safe_var.

3. Full Exploit Walkthrough
Start program:
Run the binary or connect via nc tethys.picoctf.net 49180.

View heap state:
Select menu option 1 to see both buffer contents.

Trigger overflow:
Select menu option 2 and input a string 6+ characters long (e.g., aaaaaa).
The sixth byte overwrites the first character of safe_var.

Confirm result:
Use menu option 3 to print safe_var and verify it’s no longer "bico".

Retrieve the flag:
Select menu option 4.
If the exploit worked, the program prints YOU WIN and reveals the flag.

Key Vulnerability
c
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data); // No bounds check!
}
This unsafe code allows you to overwrite adjacent heap-allocated memory, which in this case directly influences the win condition.

Exploit Summary Table
Step	Menu Option	What to Do	Why?
1	1	Print heap state	Confirm buffer values
2	2	Write aaaaaa (or similar)	Overwrite safe_var
3	3	Print safe_var to confirm corruption	Visual check
4	4	Attempt to print the flag	Flag now revealed!
Lessons Learned
Heap buffer overflows are just as dangerous as stack overflows when allocations are contiguous.

Functions like scanf("%s", ...) are inherently unsafe for bounded buffers.

Always confirm buffer boundaries and allocation order when auditing code.

